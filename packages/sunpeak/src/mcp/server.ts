import { createServer, type IncomingMessage, type ServerResponse } from 'node:http';
import { URL } from 'node:url';
import fs from 'node:fs';
import path from 'node:path';

import { FAVICON_BUFFER } from './favicon.js';

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import {
  registerAppTool,
  registerAppResource,
  RESOURCE_MIME_TYPE,
} from '@modelcontextprotocol/ext-apps/server';

import { type MCPServerConfig, type SimulationWithDist } from './types.js';

export type { MCPServerConfig, SimulationWithDist } from './types.js';

/**
 * Read pre-built resource HTML (production mode).
 * The HTML file is generated by `sunpeak build` with JS and CSS inlined.
 */
function readResourceHtmlProd(distPath: string): string {
  const htmlPath = path.resolve(distPath);

  if (!fs.existsSync(htmlPath)) {
    throw new Error(
      `Resource HTML file not found at ${htmlPath}. Run "sunpeak build" to generate the built app.`
    );
  }

  return fs.readFileSync(htmlPath, 'utf8');
}

/**
 * Generate HTML that loads from Vite dev server (dev mode with HMR).
 *
 * - Scripts load from localhost (not ngrok) to bypass ngrok warning page
 * - User must approve "local network access" in browser to allow localhost access
 * - HMR WebSocket connects to localhost
 *
 * @param srcPath - Path to the source file (e.g., "/src/resources/albums/albums-resource.tsx")
 */
function getViteResourceHtml(srcPath: string): string {
  // Extract component name from path: /src/resources/albums/albums-resource.tsx -> AlbumsResource
  const fileName =
    srcPath
      .split('/')
      .pop()
      ?.replace(/-resource\.tsx$/, '') ?? '';
  const componentName =
    fileName
      .split('-')
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join('') + 'Resource';

  // Use localhost URL for dev (not ngrok URL) to bypass ngrok warning page
  // Scripts load directly from localhost, user must approve "local network access" in browser
  const devServerUrl = 'http://localhost:8000';

  // Encode srcPath and componentName for the virtual entry module
  const entryParams = new URLSearchParams({ src: srcPath, component: componentName });
  // Vite serves virtual modules via /@id/ prefix
  const virtualModuleUrl = `${devServerUrl}/@id/virtual:sunpeak-entry?${entryParams.toString()}`;

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <script type="module">
    import { injectIntoGlobalHook } from "${devServerUrl}/@react-refresh";
    injectIntoGlobalHook(window);
    window.$RefreshReg$ = () => {};
    window.$RefreshSig$ = () => (type) => type;
    window.__vite_plugin_react_preamble_installed__ = true;
  </script>
  <script type="module" src="${devServerUrl}/@vite/client"></script>
  <script type="module">
    (async () => {
      if (!navigator.permissions?.query) return;
      const protocol = window.location.protocol;
      if (protocol !== 'http:' && protocol !== 'https:') return;
      const host = window.location.hostname;
      const isLoopback = host === 'localhost' || /^127\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/.test(host) || host === '::1';
      if (isLoopback) return;
      try {
        const status = await navigator.permissions.query({ name: "local-network-access" });
        if (status.state === "denied") {
          document.getElementById('root').innerHTML = '<div style="background:#fef2f2;border:2px solid #ef4444;border-radius:8px;padding:16px;text-align:center;font-family:system-ui,sans-serif;"><div style="color:#ef4444;font-size:18px;font-weight:600;margin-bottom:8px;">Local network access permission is denied</div><div style="color:#ef4444;font-size:14px;">Please enable it in your browser settings. <a href="https://developer.chrome.com/blog/local-network-access" target="_blank" style="color:#ef4444;text-decoration:underline;">Learn more</a></div></div>';
        }
      } catch (e) {}
    })();
  </script>
  <div id="root"></div>
  <script type="module" src="${virtualModuleUrl}"></script>
</body>
</html>`;
}

/**
 * Get resource HTML content based on mode (Vite dev or production)
 */
function getResourceHtml(simulation: SimulationWithDist, viteMode: boolean): string {
  if (viteMode && simulation.srcPath) {
    return getViteResourceHtml(simulation.srcPath);
  }
  return readResourceHtmlProd(simulation.distPath);
}

// Vite dev server URLs for CSP
const DEV_SERVER_URL = 'http://localhost:8000';
const HMR_WS_URL = 'ws://localhost:24678';

/**
 * Inject localhost URLs into CSP for Vite dev mode.
 * Uses MCP Apps metadata format: _meta.ui.csp.resourceDomains/connectDomains
 */
function injectViteCSP(existingMeta: Record<string, unknown> | undefined): Record<string, unknown> {
  const meta = existingMeta ?? {};
  const ui = (meta.ui as Record<string, unknown>) ?? {};
  const csp = (ui.csp as Record<string, unknown>) ?? {};

  const existingResourceDomains = (csp.resourceDomains as string[]) ?? [];
  const resourceDomains = existingResourceDomains.includes(DEV_SERVER_URL)
    ? existingResourceDomains
    : [...existingResourceDomains, DEV_SERVER_URL];

  const existingConnectDomains = (csp.connectDomains as string[]) ?? [];
  const connectDomains = existingConnectDomains.includes(HMR_WS_URL)
    ? existingConnectDomains
    : [...existingConnectDomains, HMR_WS_URL];

  return {
    ...meta,
    ui: {
      ...ui,
      csp: {
        ...csp,
        resourceDomains,
        connectDomains,
      },
    },
  };
}

function createAppServer(
  config: MCPServerConfig,
  simulations: SimulationWithDist[],
  viteMode: boolean
): McpServer {
  const { name = 'sunpeak-app', version = '0.1.0' } = config;

  const mcpServer = new McpServer(
    { name, version },
    { capabilities: { resources: {}, tools: {} } }
  );

  // Track registered resource URIs to avoid duplicate registration
  // (multiple simulations can share the same resource, e.g. review-diff and review-post)
  const registeredResources = new Set<string>();

  // Register each simulation's tool and resource using ext-apps helpers
  for (const simulation of simulations) {
    const resource = simulation.resource;
    const tool = simulation.tool;
    const toolResult = simulation.toolResult ?? { structuredContent: null };

    // Use the resource's URI, or derive a stable one from the resource name.
    // Must be stable across all SSE sessions — ChatGPT reads resource URIs from the tools/list
    // response in one session, then fetches the content in a separate resources/read session.
    const uri = (resource.uri as string) ?? `ui://${resource.name as string}`;
    const resourceMeta = (resource._meta as Record<string, unknown>) ?? {};
    const toolMeta = (tool._meta as Record<string, unknown>) ?? {};

    // Register the resource using ext-apps helper (only once per URI)
    // This sets RESOURCE_MIME_TYPE automatically
    if (!registeredResources.has(uri)) {
      registeredResources.add(uri);
      registerAppResource(
        mcpServer,
        resource.name as string,
        uri,
        {
          description: resource.description as string | undefined,
          _meta: viteMode ? { ui: injectViteCSP(resourceMeta)?.ui } : resourceMeta,
        },
        async () => {
          console.log(`[MCP] ReadResource: ${uri}${viteMode ? ' (vite)' : ''}`);
          let content: string;
          try {
            content = getResourceHtml(simulation, viteMode);
          } catch (error) {
            console.error(`[MCP] ReadResource error for ${uri}:`, error);
            throw error;
          }
          const sizeKB = (content.length / 1024).toFixed(1);
          console.log(`[MCP] ReadResource: ${uri} → ${sizeKB}KB`);

          return {
            contents: [
              {
                uri,
                mimeType: RESOURCE_MIME_TYPE,
                text: content,
                _meta: viteMode ? injectViteCSP(resourceMeta) : resourceMeta,
              },
            ],
          };
        }
      );
    }

    // Register the tool using ext-apps helper
    // This normalizes the ui/resourceUri metadata automatically
    // Note: inputSchema from simulation is JSON Schema, not Zod, so we omit it here
    // (simulation mode doesn't validate inputs - just logs what was called)
    registerAppTool(
      mcpServer,
      tool.name as string,
      {
        description: tool.description as string | undefined,
        _meta: {
          ...toolMeta,
          ui: { resourceUri: uri },
        },
      },
      async (extra) => {
        // Access arguments from request context (no inputSchema = no parsed args)
        const args =
          (extra as { request?: { params?: { arguments?: Record<string, unknown> } } }).request
            ?.params?.arguments ?? {};
        const argKeys = Object.keys(args);
        const argsStr = argKeys.length > 0 ? `{${argKeys.join(', ')}}` : '{}';
        const hasStructuredContent = toolResult?.structuredContent != null;

        console.log(
          `[MCP] CallTool: ${tool.name}${argsStr} → ${hasStructuredContent ? 'structured' : 'text'}`
        );

        return {
          content: [
            {
              type: 'text' as const,
              text: `Rendered ${tool.description}!`,
            },
          ],
          structuredContent:
            (toolResult?.structuredContent as Record<string, unknown>) ?? undefined,
        };
      }
    );
  }

  const registeredUris = Array.from(registeredResources).join(', ');
  console.log(
    `[MCP] Registered ${simulations.length} tool(s) and resource(s)${viteMode ? ' (vite mode)' : ''}: ${registeredUris}`
  );

  return mcpServer;
}

type SessionRecord = {
  server: McpServer;
  transport: SSEServerTransport;
};

const sessions = new Map<string, SessionRecord>();

const ssePath = '/mcp';
const postPath = '/mcp/messages';

async function handleSseRequest(
  res: ServerResponse,
  config: MCPServerConfig,
  simulations: SimulationWithDist[],
  viteMode: boolean
) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  const server = createAppServer(config, simulations, viteMode);
  const transport = new SSEServerTransport(postPath, res);
  const sessionId = transport.sessionId;

  sessions.set(sessionId, { server, transport });
  console.log(`[MCP] Session started: ${sessionId.substring(0, 8)}... (${sessions.size} active)`);

  transport.onclose = async () => {
    // Guard against re-entrancy (server.close() may trigger onclose again)
    if (!sessions.has(sessionId)) return;
    sessions.delete(sessionId);
    console.log(`[MCP] Session closed: ${sessionId.substring(0, 8)}... (${sessions.size} active)`);
    await server.close();
  };

  transport.onerror = (error) => {
    console.error(`[MCP] SSE transport error (${sessionId.substring(0, 8)}...):`, error);
  };

  try {
    await server.connect(transport);
  } catch (error) {
    sessions.delete(sessionId);
    console.error(`[MCP] Failed to start session (${sessionId.substring(0, 8)}...):`, error);
    if (!res.headersSent) {
      res.writeHead(500).end('Failed to establish SSE connection');
    }
  }
}

async function handlePostMessage(req: IncomingMessage, res: ServerResponse, url: URL) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Headers', 'content-type, ngrok-skip-browser-warning');
  const sessionId = url.searchParams.get('sessionId');

  if (!sessionId) {
    res.writeHead(400).end('Missing sessionId query parameter');
    return;
  }

  const session = sessions.get(sessionId);

  if (!session) {
    res.writeHead(404).end('Unknown session');
    return;
  }

  // Buffer body to log the MCP method, then pass pre-parsed to avoid re-reading the stream
  const chunks: Buffer[] = [];
  await new Promise<void>((resolve, reject) => {
    req.on('data', (chunk: Buffer | string) => {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk as string));
    });
    req.on('end', resolve);
    req.on('error', reject);
  });
  const rawBody = Buffer.concat(chunks).toString('utf8');

  try {
    const parsed = JSON.parse(rawBody) as {
      method?: string;
      id?: string | number;
      params?: Record<string, unknown>;
    };
    if (parsed.method) {
      const extra =
        parsed.method === 'resources/read' ? ` uri=${JSON.stringify(parsed.params?.uri)}` : '';
      console.log(`[MCP] ← ${parsed.method}${extra} (${sessionId.substring(0, 8)}...)`);
    }
  } catch {}

  try {
    await session.transport.handlePostMessage(req, res, rawBody);
  } catch (error) {
    console.error('Failed to process message', error);
    if (!res.headersSent) {
      res.writeHead(500).end('Failed to process message');
    }
  }
}

// Type for Vite dev server (minimal interface we need)
interface ViteDevServer {
  middlewares: {
    (req: IncomingMessage, res: ServerResponse, next?: () => void): void;
  };
  ws: {
    handleUpgrade: (
      request: IncomingMessage,
      socket: import('node:stream').Duplex,
      head: Buffer
    ) => void;
  };
}

/**
 * Run the MCP server with the specified configuration.
 *
 * @param config - Server configuration with simulations.
 */
export function runMCPServer(config: MCPServerConfig): void {
  const portEnv = Number(process.env.PORT ?? 8000);
  const port = config.port ?? (Number.isFinite(portEnv) ? portEnv : 8000);
  const { simulations } = config;

  // Check if Vite dev server is provided
  const viteServer = config.viteServer as ViteDevServer | undefined;
  const viteMode = !!viteServer;

  const httpServer = createServer(async (req: IncomingMessage, res: ServerResponse) => {
    if (!req.url) {
      res.writeHead(400).end('Missing URL');
      return;
    }

    const url = new URL(req.url, `http://${req.headers.host ?? 'localhost'}`);

    // CORS preflight for all routes
    if (req.method === 'OPTIONS') {
      res.writeHead(204, {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'content-type, ngrok-skip-browser-warning',
      });
      res.end();
      return;
    }

    // Root path (ChatGPT checks this before fetching favicon)
    if (req.method === 'GET' && url.pathname === '/') {
      res.writeHead(200, {
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin': '*',
      });
      res.end(`<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<link rel="icon" type="image/png" href="/favicon.ico" />
<title>Sunpeak MCP Server</title>
</head>
<body><h1>Sunpeak MCP Server</h1><p>Connect via <a href="/mcp">/mcp</a></p></body>
</html>`);
      return;
    }

    // Favicon endpoint (ChatGPT fetches this when connecting to an MCP server)
    if (req.method === 'GET' && url.pathname === '/favicon.ico') {
      res.writeHead(200, {
        'Content-Type': 'image/png',
        'Content-Length': FAVICON_BUFFER.length,
        'Cache-Control': 'public, max-age=86400',
        'Access-Control-Allow-Origin': '*',
      });
      res.end(FAVICON_BUFFER);
      return;
    }

    // MCP SSE endpoint
    if (req.method === 'GET' && url.pathname === ssePath) {
      console.log(`[HTTP] ${req.method} ${url.pathname}`);
      await handleSseRequest(res, config, simulations, viteMode);
      return;
    }

    // MCP message endpoint
    if (req.method === 'POST' && url.pathname === postPath) {
      console.log(`[HTTP] ${req.method} ${url.pathname}`);
      await handlePostMessage(req, res, url);
      return;
    }

    // If Vite server is available, delegate all other requests to it
    if (viteServer) {
      // Add CORS headers for Vite-served content (needed for cross-origin widget loading)
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Headers', 'content-type, ngrok-skip-browser-warning');
      viteServer.middlewares(req, res);
      return;
    }

    // No Vite server, return 404 for non-MCP routes
    console.log(`[HTTP] ${req.method} ${url.pathname} → 404`);
    res.writeHead(404).end('Not Found');
  });

  // Handle WebSocket upgrades for Vite HMR
  if (viteServer) {
    httpServer.on('upgrade', (request, socket, head) => {
      // Forward all WebSocket upgrades to Vite (it handles /@vite/ws)
      viteServer.ws.handleUpgrade(request, socket, head);
    });
  }

  httpServer.on('clientError', (err: Error, socket) => {
    console.error('HTTP client error', err);
    socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
  });

  httpServer.listen(port, () => {
    console.log(`Sunpeak MCP server listening on http://localhost:${port}`);
    console.log(`  SSE stream: GET http://localhost:${port}${ssePath}`);
    if (viteMode) {
      console.log(`  Vite HMR: enabled (source files served with hot reload)`);
    }
  });

  // Graceful shutdown handler
  const shutdown = async () => {
    console.log('\nShutting down MCP server...');

    httpServer.close(() => {
      console.log('MCP server closed');
      process.exit(0);
    });

    // Force close after 5 seconds if graceful shutdown fails
    setTimeout(() => {
      console.error('Force closing MCP server');
      process.exit(1);
    }, 5000);
  };

  process.on('SIGTERM', () => void shutdown());
  process.on('SIGINT', () => void shutdown());
}
